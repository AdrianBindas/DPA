
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pipeline.DPA module &#8212; DPA  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "document", "processHtmlClass": "math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-Pipeline.DPA">
<span id="pipeline-dpa-module"></span><h1>Pipeline.DPA module<a class="headerlink" href="#module-Pipeline.DPA" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">DensityPeakAdvanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">densities</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_densities</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_hat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affinity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'precomputed'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_algo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PAk'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">23.92812698</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_algo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'twoNN'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blockAn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#DensityPeakAdvanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.ClusterMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Class definition for the non-parametric Density Peak clustering.</p>
<p>The default pipeline makes use of the <cite>PAk</cite> density estimator and of the <cite>TWO-NN</cite> intristic dimension estimator.
The densities and the corresponding errors can also be provided as precomputed arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Z</strong> (<em>float</em><em>, </em><em>default = 1</em>) – The number of standard deviations, which fixes the level of statistical confidence at which
one decides to consider a cluster meaningful.</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, or </em><em>callable</em>) – The distance metric to use.
If metric is a string, it must be one of the options allowed by
scipy.spatial.distance.pdist for its metric parameter, or a metric listed in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_METRIC</span> <span class="pre">=</span> <span class="pre">[precomputed,</span> <span class="pre">euclidean,cosine]</span></code>. If metric is <code class="docutils literal notranslate"><span class="pre">precomputed</span></code>, X is assumed to
be a distance matrix. Alternatively, if metric is a callable function, it is
called on each pair of instances (rows) and the resulting value recorded. The
callable should take two arrays from X as input and return a value indicating
the distance between them. Default is <code class="docutils literal notranslate"><span class="pre">euclidean</span></code>.</p></li>
<li><p><strong>densities</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em><em>, </em><em>default = None</em>) – The logarithm of the density at each point. If provided, the following parameters are ignored:
<code class="docutils literal notranslate"><span class="pre">density_algo</span></code>, <code class="docutils literal notranslate"><span class="pre">k_max</span></code>, <code class="docutils literal notranslate"><span class="pre">D_thr</span></code>.</p></li>
<li><p><strong>err_densities</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em><em>, </em><em>default = None</em>) – The uncertainty in the density estimation, obtained by computing
the inverse of the Fisher information matrix.</p></li>
<li><p><strong>k_hat</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em><em>, </em><em>default = None</em>) – The optimal number of neighbors for which the condition of constant density holds.</p></li>
<li><p><strong>nn_distances</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Distances to the k_max neighbors of each points.</p></li>
<li><p><strong>nn_indices</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Indices of the k_max neighbors of each points.</p></li>
<li><p><strong>affinity</strong> (<em>string</em><em> or </em><em>callable</em><em>, </em><em>default 'precomputed'</em>) – <dl class="simple">
<dt>How to construct the affinity matrix.</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> : construct the affinity matrix by computing a
graph of nearest neighbors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rbf</span></code> : construct the affinity matrix using a radial basis function
(RBF) kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">precomputed</span></code> : interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a precomputed affinity matrix.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">precomputed_nearest_neighbors</span></code> : interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a sparse graph
of precomputed nearest neighbors, and constructs the affinity matrix
by selecting the <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> nearest neighbors.</p></li>
<li><p>one of the kernels supported by
<code class="xref py py-func docutils literal notranslate"><span class="pre">pairwise_kernels()</span></code>.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>density_algo</strong> (<em>string</em><em>, </em><em>default = &quot;PAk&quot;</em>) – Define the algorithm to use as density estimator. It mast be one of the options allowed by
<code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_DENSITY</span> <span class="pre">=</span> <span class="pre">[PAk,</span> <span class="pre">kNN]</span></code>.</p></li>
<li><p><strong>k_max</strong> (<em>int</em><em>, </em><em>default=1000</em>) – This parameter is considered if density_algo is <code class="docutils literal notranslate"><span class="pre">PAk</span></code> or <code class="docutils literal notranslate"><span class="pre">kNN</span></code>, it is ignored otherwise.
k_max set the maximum number of nearest-neighbors considered by the density estimator.
If <code class="docutils literal notranslate"><span class="pre">density_algo=PAk</span></code>, k_max is used by the algorithm in the search for the
largest number of neighbors <code class="docutils literal notranslate"><span class="pre">k_hat</span></code> for which the condition of constant density
holds, within a given level of confidence.
If <code class="docutils literal notranslate"><span class="pre">density_algo=kNN</span></code>, k_max set the number of neighbors to be used by the standard
k-Nearest Neighbor algorithm.
If the number of points in the sample N is
less than the default value, k_max will be set automatically to the value <code class="docutils literal notranslate"><span class="pre">N/2</span></code>.</p></li>
<li><p><strong>D_thr</strong> (<em>float</em><em>, </em><em>default=23.92812698</em>) – This parameter is considered if density_algo is <code class="docutils literal notranslate"><span class="pre">PAk</span></code>, it is ignored otherwise.
Set the level of confidence in the PAk density estimator. The default value corresponds to a p-value of
<span class="math notranslate nohighlight">\(10^{-6}\)</span> for a <span class="math notranslate nohighlight">\(\chiˆ2\)</span> distribution with one degree of freedom.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>default = None</em>) – Intrinsic dimensionality of the sample. If dim is provided, the following parameters are ignored:
<code class="docutils literal notranslate"><span class="pre">dim_algo</span></code>, <code class="docutils literal notranslate"><span class="pre">blockAn</span></code>, <code class="docutils literal notranslate"><span class="pre">block_ratio</span></code>, <code class="docutils literal notranslate"><span class="pre">frac</span></code>.</p></li>
<li><p><strong>dim_algo</strong> (<em>string</em><em>, or </em><em>callable</em><em>, </em><em>default=&quot;twoNN&quot;</em>) – Method for intrinsic dimensionality calculation. If dim_algo is <code class="docutils literal notranslate"><span class="pre">auto</span></code>, dim is assumed to be
equal to n_samples. If dim_algo is a string, it must be one of the options allowed by <code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_DIM</span> <span class="pre">=</span> <span class="pre">[auto,</span> <span class="pre">twoNN]</span></code>.</p></li>
<li><p><strong>blockAn</strong> (<em>bool</em><em>, </em><em>default=True</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
If blockAn is True the algorithm perform a block analysis that allows discriminating the relevant dimensions
as a function of the block size. This allows to study the stability of the estimation with respect to
changes in the neighborhood size, which is crucial for ID estimations when the data lie on a
manifold perturbed by a high-dimensional noise.</p></li>
<li><p><strong>block_ratio</strong> (<em>int</em><em>, </em><em>default=5</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
Set the minimum size of the blocks as <cite>n_samples/block_ratio</cite>. If <code class="docutils literal notranslate"><span class="pre">blockAn=False</span></code>, <code class="docutils literal notranslate"><span class="pre">block_ratio</span></code> is ignored.</p></li>
<li><p><strong>frac</strong> (<em>float</em><em>, </em><em>default=1</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
Define the fraction of points in the data set used for ID calculation. By default the full data set is used.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation. This works by computing
each of the n_init runs in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.labels_">
<span class="sig-name descname"><span class="pre">labels_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.labels_" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering labels assigned to each point in the data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.halos_">
<span class="sig-name descname"><span class="pre">halos_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.halos_" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering labels assigned to each point in the data set. Points identified as halos have
label equal to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.topography_">
<span class="sig-name descname"><span class="pre">topography_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.topography_" title="Permalink to this definition">¶</a></dt>
<dd><p>Let be Nclus the number of clusters, the topography consists in a Nclus × Nclus symmetric matrix,
in which the diagonal entries are the heights of the peaks and the off-diagonal entries are the
heights of the saddle points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus, Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.nn_distances_">
<span class="sig-name descname"><span class="pre">nn_distances_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.nn_distances_" title="Permalink to this definition">¶</a></dt>
<dd><p>Distances to the k_max neighbors of each points. The point itself is included in the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples, k_max+1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.nn_indices_">
<span class="sig-name descname"><span class="pre">nn_indices_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.nn_indices_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of the k_max neighbors of each points. The point itself is included in the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples, k_max+1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.k_hat_">
<span class="sig-name descname"><span class="pre">k_hat_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.k_hat_" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal number of neighbors for which the condition of constant density holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.centers_">
<span class="sig-name descname"><span class="pre">centers_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.centers_" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering labels assigned to each point in the data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.dim_">
<span class="sig-name descname"><span class="pre">dim_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.dim_" title="Permalink to this definition">¶</a></dt>
<dd><p>Intrinsic dimensionality of the sample. If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is not provided, <code class="docutils literal notranslate"><span class="pre">dim_</span></code> is set
to the number of features in the input file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.k_max_">
<span class="sig-name descname"><span class="pre">k_max_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.k_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of nearest-neighbors considered by the procedure that returns the
largest number of neighbors <code class="docutils literal notranslate"><span class="pre">k_hat</span></code> for which the condition of constant density
holds, within a given level of confidence. If the number of points in the sample <cite>N</cite> is
less than the default value, <a href="#id1"><span class="problematic" id="id2">k_max_</span></a> will be set automatically to the value <code class="docutils literal notranslate"><span class="pre">N/2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.densities_">
<span class="sig-name descname"><span class="pre">densities_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.densities_" title="Permalink to this definition">¶</a></dt>
<dd><p>If not provided by the parameter <code class="docutils literal notranslate"><span class="pre">densities</span></code>, it is computed by using the <cite>PAk</cite> density estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.err_densities_">
<span class="sig-name descname"><span class="pre">err_densities_</span></span><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.err_densities_" title="Permalink to this definition">¶</a></dt>
<dd><p>The uncertainty in the density estimation. If not provided by the parameter <code class="docutils literal notranslate"><span class="pre">densities</span></code>, it is
computed by using the <cite>PAk</cite> density estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<p class="rubric">References</p>
<ol class="upperalpha simple" start="13">
<li><p>d’Errico, E. Facco, A. Laio and A. Rodriguez, Automatic topography of high-dimensional data sets by non-parametric Density Peak clustering (2018) <a class="reference external" href="https://arxiv.org/abs/1802.10549">https://arxiv.org/abs/1802.10549</a></p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#DensityPeakAdvanced.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the DPA clustering on the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>n_samples</em><em>] </em><em>if metric == “precomputed”</em><em>, </em><em>or</em><em>,</em>) – [n_samples, n_features] otherwise
The input samples. Similarities / affinities between
instances if <code class="docutils literal notranslate"><span class="pre">affinity='precomputed'</span></code>.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – Not used, present here for API consistency by convention.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.fit_predict">
<span class="sig-name descname"><span class="pre">fit_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#DensityPeakAdvanced.fit_predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.fit_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform DPA clustering from features or distance matrix,
and return cluster labels.
:param X: Training instances to cluster, or distances between instances if</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">metric='precomputed'</span></code>. If a sparse matrix is provided, it will
be converted into a sparse <code class="docutils literal notranslate"><span class="pre">csr_matrix</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> (<em>Ignored</em>) – Not used, present here for API consistency by convention.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>labels</strong> – Cluster labels. Noisy samples are given the label -1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.get_computed_params">
<span class="sig-name descname"><span class="pre">get_computed_params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#DensityPeakAdvanced.get_computed_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.get_computed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.DPA.DensityPeakAdvanced.get_histogram">
<span class="sig-name descname"><span class="pre">get_histogram</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#DensityPeakAdvanced.get_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA.DensityPeakAdvanced.get_histogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Pipeline.DPA._DensityPeakAdvanced">
<span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">_DensityPeakAdvanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">densities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_densities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/DPA.html#_DensityPeakAdvanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.DPA._DensityPeakAdvanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Main function implementing the Density Peak Advanced clustering algorithm:</p>
<ul class="simple">
<li><p>Automatic detection of cluster centers</p></li>
<li><p>Point assignament to clusters in order of decreasing <cite>g</cite></p></li>
<li><p>Topography reconstruction: search of saddle points and cluster merging</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>densities</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em>) – The logarithm of the density at each point.</p></li>
<li><p><strong>err_densities</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em>) – The uncertainty in the density estimation, obtained by computing
the inverse of the Fisher information matrix.</p></li>
<li><p><strong>k_hat</strong> (<em>array</em><em> [</em><em>n_samples</em><em>]</em>) – The optimal number of neighbors for which the condition of constant density holds.</p></li>
<li><p><strong>distances</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Distances to the k_max neighbors of each points. The point itself is included in the array.</p></li>
<li><p><strong>indices</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Indices of the k_max neighbors of each points. The point itself is included in the array.</p></li>
<li><p><strong>Z</strong> (<em>float</em><em>, </em><em>default = 1</em>) – The number of standard deviations, which fixes the level of statistical confidence at which
one decides to consider a cluster meaningful.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.labels">
<span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">labels</span></span><a class="headerlink" href="#Pipeline.DPA.labels" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering labels assigned to each point in the data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.halos">
<span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">halos</span></span><a class="headerlink" href="#Pipeline.DPA.halos" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering labels assigned to each point in the data set. Points identified as halos have
clustering lable equal to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.topography">
<span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">topography</span></span><a class="headerlink" href="#Pipeline.DPA.topography" title="Permalink to this definition">¶</a></dt>
<dd><p>Let be Nclus the number of clusters, the topography consists in a Nclus × Nclus symmetric matrix,
in which the diagonal entries are the heights of the peaks and the off-diagonal entries are the
heights of the saddle points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus, Nclus]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.DPA.centers">
<span class="sig-prename descclassname"><span class="pre">Pipeline.DPA.</span></span><span class="sig-name descname"><span class="pre">centers</span></span><a class="headerlink" href="#Pipeline.DPA.centers" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of points identified as the centers of the Nclus statistically significant clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [Nclus]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Pipeline.PAk">
<span id="pipeline-pak-module"></span><h1>Pipeline.PAk module<a class="headerlink" href="#module-Pipeline.PAk" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">PointAdaptive_kNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">23.92812698</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_algo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blockAn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/PAk.html#PointAdaptive_kNN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Class definition for the Pointwise Adaptive k-NN density estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_max</strong> (<em>int</em><em>, </em><em>default=1000</em>) – The maximum number of nearest-neighbors considered by the procedure that returns the
largest number of neighbors <code class="docutils literal notranslate"><span class="pre">k_hat</span></code> for which the condition of constant density
holds, within a given level of confidence. If the number of points in the sample <cite>N</cite> is
less than the default value, k_max will be set automatically to the value <code class="docutils literal notranslate"><span class="pre">N/2</span></code>.</p></li>
<li><p><strong>D_thr</strong> (<em>float</em><em>, </em><em>default=23.92812698</em>) – Set the level of confidence. The default value corresponds to a p-value of
<span class="math notranslate nohighlight">\(10^{-6}\)</span> for a <span class="math notranslate nohighlight">\(\chiˆ2\)</span> distribution with one degree of freedom.</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, or </em><em>callable</em>) – The distance metric to use.
If metric is a string, it must be one of the options allowed by
scipy.spatial.distance.pdist for its metric parameter, or a metric listed in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_METRIC</span> <span class="pre">=</span> <span class="pre">[precomputed,</span> <span class="pre">euclidean,cosine]</span></code>. If metric is <code class="docutils literal notranslate"><span class="pre">precomputed</span></code>, X is assumed to
be a distance matrix. Alternatively, if metric is a callable function, it is
called on each pair of instances (rows) and the resulting value recorded. The
callable should take two arrays from X as input and return a value indicating
the distance between them. Default is <code class="docutils literal notranslate"><span class="pre">euclidean</span></code>.</p></li>
<li><p><strong>dim_algo</strong> (<em>string</em><em>, or </em><em>callable</em>) – Method for intrinsic dimensionality calculation. If dim_algo is <code class="docutils literal notranslate"><span class="pre">auto</span></code>, dim is assumed to be
equal to n_samples. If dim_algo is a string, it must be one of the options allowed by <code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_DIM</span> <span class="pre">=</span> <span class="pre">[auto,</span> <span class="pre">twoNN]</span></code>.</p></li>
<li><p><strong>nn_distances</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Distances to the k_max neighbors of each points.</p></li>
<li><p><strong>nn_indices</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Indices of the k_max neighbors of each points.</p></li>
<li><p><strong>blockAn</strong> (<em>bool</em><em>, </em><em>default=True</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
If blockAn is True the algorithm perform a block analysis that allows discriminating the relevant dimensions
as a function of the block size. This allows to study the stability of the estimation with respect to
changes in the neighborhood size, which is crucial for ID estimations when the data lie on a manifold perturbed
by a high-dimensional noise.</p></li>
<li><p><strong>block_ratio</strong> (<em>int</em><em>, </em><em>default=20</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
Set the minimum size of the blocks as <cite>n_samples/block_ratio</cite>. If <code class="docutils literal notranslate"><span class="pre">blockAn=False</span></code>, block_ratio is ignored.</p></li>
<li><p><strong>frac</strong> (<em>float</em><em>, </em><em>default=1</em>) – This parameter is considered if dim_algo is <code class="docutils literal notranslate"><span class="pre">twoNN</span></code>, it is ignored otherwise.
Define the fraction of points in the data set used for ID calculation. By default the full data set is used.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – Intrinsic dimensionality of the sample. If dim is provided, dim_algo is ignored.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation. This works by computing
each of the n_init runs in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.dim_">
<span class="sig-name descname"><span class="pre">dim_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.dim_" title="Permalink to this definition">¶</a></dt>
<dd><p>Intrinsic dimensionality of the sample. If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is not provided, <code class="docutils literal notranslate"><span class="pre">dim_</span></code> is set
to the number of features in the input file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.k_max_">
<span class="sig-name descname"><span class="pre">k_max_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.k_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of nearest-neighbors considered by the procedure that returns the
largest number of neighbors <code class="docutils literal notranslate"><span class="pre">k_hat</span></code> for which the condition of constant density
holds, within a given level of confidence. If the number of points in the sample <cite>N</cite> is
less than the default value, <a href="#id3"><span class="problematic" id="id4">k_max_</span></a> will be set automatically to the value <code class="docutils literal notranslate"><span class="pre">N/2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.distances_">
<span class="sig-name descname"><span class="pre">distances_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.distances_" title="Permalink to this definition">¶</a></dt>
<dd><p>Distances to the k_max neighbors of each points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples, k_max+1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.indices_">
<span class="sig-name descname"><span class="pre">indices_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.indices_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of the k_max neighbors of each points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples, k_max+1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.densities_">
<span class="sig-name descname"><span class="pre">densities_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.densities_" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm of the density at each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.err_densities_">
<span class="sig-name descname"><span class="pre">err_densities_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.err_densities_" title="Permalink to this definition">¶</a></dt>
<dd><p>The uncertainty in the density estimation, obtained by computing
the inverse of the Fisher information matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.k_hat_">
<span class="sig-name descname"><span class="pre">k_hat_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.k_hat_" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal number of neighbors for which the condition of constant density holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.dc_">
<span class="sig-name descname"><span class="pre">dc_</span></span><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.dc_" title="Permalink to this definition">¶</a></dt>
<dd><p>The radius of the optimal neighborhood for each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_sample]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">DPA</span> <span class="kn">import</span> <span class="n">PAk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">PAk</span><span class="o">.</span><span class="n">PointAdaptive_kNN</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">distances_</span>
<span class="go">array([[0.        , 1.        , 1.        ],</span>
<span class="go">       [0.        , 1.        , 1.41421356],</span>
<span class="go">       [0.        , 1.        , 1.41421356],</span>
<span class="go">       [0.        , 1.41421356, 2.23606798],</span>
<span class="go">       [0.        , 1.        , 2.23606798],</span>
<span class="go">       [0.        , 1.        , 1.41421356]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">indices_</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 0, 2],</span>
<span class="go">       [2, 0, 1],</span>
<span class="go">       [3, 5, 4],</span>
<span class="go">       [4, 5, 3],</span>
<span class="go">       [5, 4, 3]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="upperalpha simple">
<li><p>Rodriguez, M. d’Errico, E. Facco and A. Laio, Computing the free energy without collective variables. <cite>J. chemical theory computation</cite> 14, 1206–1215 (2018).</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.PAk.PointAdaptive_kNN.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/PAk.html#PointAdaptive_kNN.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.PAk.PointAdaptive_kNN.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the PAk estimator on the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (array [n_samples, n_samples] if metric == <code class="docutils literal notranslate"><span class="pre">precomputed</span></code>, or,) – [n_samples, n_features] otherwise
The input samples.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – Not used, present here for API consistency by convention.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Pipeline.PAk._PointAdaptive_kNN">
<span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">_PointAdaptive_kNN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">23.92812698</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/PAk.html#_PointAdaptive_kNN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.PAk._PointAdaptive_kNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Main function implementing the Pointwise Adaptive k-NN density estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distances</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Distances to the k_max neighbors of each points. The point is included.</p></li>
<li><p><strong>indices</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max+1</em><em>]</em>) – Indices of the k_max neighbors of each points. The point is included.</p></li>
<li><p><strong>k_max</strong> (<em>int</em><em>, </em><em>default=1000</em>) – The maximum number of nearest-neighbors considered by the procedure that returns the
largest number of neighbors <code class="docutils literal notranslate"><span class="pre">k_hat</span></code> for which the condition of constant density
holds, within a given level of confidence. If the number of points in the sample <cite>N</cite> is
less than the default value, k_max will be set automatically to the value <code class="docutils literal notranslate"><span class="pre">N/2</span></code>.</p></li>
<li><p><strong>D_thr</strong> (<em>float</em><em>, </em><em>default=23.92812698</em>) – Set the level of confidence. The default value corresponds to a p-value of
<span class="math notranslate nohighlight">\(10^{-6}\)</span> for a <span class="math notranslate nohighlight">\(\chiˆ2\)</span> distribution with one degree of freedom.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – Intrinsic dimensionality of the sample.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.densities">
<span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">densities</span></span><a class="headerlink" href="#Pipeline.PAk.densities" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm of the density at each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.err_densities">
<span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">err_densities</span></span><a class="headerlink" href="#Pipeline.PAk.err_densities" title="Permalink to this definition">¶</a></dt>
<dd><p>The uncertainty in the density estimation, obtained by computing
the inverse of the Fisher information matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.k_hat">
<span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">k_hat</span></span><a class="headerlink" href="#Pipeline.PAk.k_hat" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal number of neighbors for which the condition of constant density holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.PAk.dc">
<span class="sig-prename descclassname"><span class="pre">Pipeline.PAk.</span></span><span class="sig-name descname"><span class="pre">dc</span></span><a class="headerlink" href="#Pipeline.PAk.dc" title="Permalink to this definition">¶</a></dt>
<dd><p>The radius of the optimal neighborhood for each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array [n_sample]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Pipeline.twoNN">
<span id="pipeline-twonn-module"></span><h1>Pipeline.twoNN module<a class="headerlink" href="#module-Pipeline.twoNN" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="Pipeline.twoNN._twoNearestNeighbors">
<span class="sig-prename descclassname"><span class="pre">Pipeline.twoNN.</span></span><span class="sig-name descname"><span class="pre">_twoNearestNeighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blockAn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/twoNN.html#_twoNearestNeighbors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.twoNN._twoNearestNeighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Main function for the TWO-NN estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distances</strong> (<em>array</em><em> [</em><em>n_samples</em><em>, </em><em>k_max</em><em>]</em>) – Distances to the k_max neighbors of each points.</p></li>
<li><p><strong>blockAn</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If blockAn is True the algorithm perform a block analysis that allows discriminating the relevant dimensions
as a function of the block size. This allows to study the stability of the estimation with respect to
changes in the neighborhood size, which is crucial for ID estimations when the data lie on a manifold perturbed
by a high-dimensional noise.</p></li>
<li><p><strong>block_ratio</strong> (<em>int</em><em>, </em><em>default=20</em>) – Set the minimum size of the blocks as <cite>n_samples/block_ratio</cite>. If <code class="docutils literal notranslate"><span class="pre">blockAn=False</span></code>, block_ratio is ignored.</p></li>
<li><p><strong>frac</strong> (<em>float</em><em>, </em><em>default=1</em>) – Define the fraction of points in the data set used for ID calculation. By default the full data set is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Pipeline.twoNN.twoNearestNeighbors">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">Pipeline.twoNN.</span></span><span class="sig-name descname"><span class="pre">twoNearestNeighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blockAn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affinity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'precomputed'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/twoNN.html#twoNearestNeighbors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.twoNN.twoNearestNeighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Class definition for TWO-NN: Intrinsic dimension estimator by a minimal neighborhood information.</p>
<p>The TWO-NN estimator uses only the distances to the first two nearest neighbors of each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, or </em><em>callable</em>) – The distance metric to use.
If metric is a string, it must be one of the options allowed by
scipy.spatial.distance.pdist for its metric parameter, or a metric listed in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">VALID_METRIC</span> <span class="pre">=</span> <span class="pre">[precomputed,</span> <span class="pre">euclidean,cosine]</span></code>. If metric is <code class="docutils literal notranslate"><span class="pre">precomputed</span></code>, X is assumed to
be a distance matrix. Alternatively, if metric is a callable function, it is
called on each pair of instances (rows) and the resulting value recorded. The
callable should take two arrays from X as input and return a value indicating
the distance between them. Default is <code class="docutils literal notranslate"><span class="pre">euclidean</span></code>.</p></li>
<li><p><strong>blockAn</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If blockAn is True the algorithm perform a block analysis that allows discriminating the relevant dimensions
as a function of the block size. This allows to study the stability of the estimation with respect to
changes in the neighborhood size, which is crucial for ID estimations when the data lie on a manifold perturbed
by a high-dimensional noise.</p></li>
<li><p><strong>block_ratio</strong> (<em>int</em><em>, </em><em>default=20</em>) – Set the minimum size of the blocks as <cite>n_samples/block_ratio</cite>. If <code class="docutils literal notranslate"><span class="pre">blockAn=False</span></code>, block_ratio is ignored.</p></li>
<li><p><strong>frac</strong> (<em>float</em><em>, </em><em>default=1</em>) – Define the fraction of points in the data set used for ID calculation. By default the full data set is used.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation. This works by computing
each of the n_init runs in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>affinity</strong> (<em>string</em><em> or </em><em>callable</em><em>, </em><em>default 'precomputed'</em>) – <dl class="simple">
<dt>How to construct the affinity matrix.</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> : construct the affinity matrix by computing a
graph of nearest neighbors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rbf</span></code> : construct the affinity matrix using a radial basis function
(RBF) kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">precomputed</span></code> : interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a precomputed affinity matrix.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">precomputed_nearest_neighbors</span></code> : interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a sparse graph
of precomputed nearest neighbors, and constructs the affinity matrix
by selecting the <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> nearest neighbors.</p></li>
<li><p>one of the kernels supported by
<code class="xref py py-func docutils literal notranslate"><span class="pre">pairwise_kernels()</span></code>.</p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="Pipeline.twoNN.twoNearestNeighbors.dim_">
<span class="sig-name descname"><span class="pre">dim_</span></span><a class="headerlink" href="#Pipeline.twoNN.twoNearestNeighbors.dim_" title="Permalink to this definition">¶</a></dt>
<dd><p>The intrinsic dimensionality</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<ol class="upperalpha simple" start="5">
<li><p>Facco, M. d’Errico, A. Rodriguez and A. Laio, Estimating the intrinsic dimension of datasets by a minimal neighborhood information. <cite>Sci. reports</cite> 7, 12140 (2017)</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="Pipeline.twoNN.twoNearestNeighbors.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Pipeline/twoNN.html#twoNearestNeighbors.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#Pipeline.twoNN.twoNearestNeighbors.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference implementation of a fitting function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (array [n_samples, n_samples] if metric == <code class="docutils literal notranslate"><span class="pre">precomputed</span></code>, or,) – [n_samples, n_features] otherwise
The input samples. Similarities / affinities between
instances if <code class="docutils literal notranslate"><span class="pre">affinity='precomputed'</span></code>.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – Not used, present here for API consistency by convention.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">DPA</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Density Peaks Advanced clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="jupyter_analysis.html">The Density Peak Advanced clustering algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="jupyter_comparison.html">Clustering algorithms at comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Package modules</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Maria d'Errico.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/Pipeline.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>